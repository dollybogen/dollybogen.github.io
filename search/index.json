[{"content":"1. 两数之和 简单\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案。\n示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2]\n示例 3： 输入：nums = [3,3], target = 6 输出：[0,1]\n两数之和\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int,int\u0026gt;hash_map; for(int i=0;i\u0026lt;nums.size();i++) { auto it =hash_map.find(target-nums[i]); if(it !=hash_map.end()) { return {it-\u0026gt;second,i}; } hash_map[nums[i]]=i; } return{}; } }; 解法 使用unordered_map对数组进行遍历，查看另一半是否在unordered_map中，不在就加入，存在就返回\n49. 字母异位词分组 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\n示例 1: 输入: strs = [\u0026ldquo;eat\u0026rdquo;, \u0026ldquo;tea\u0026rdquo;, \u0026ldquo;tan\u0026rdquo;, \u0026ldquo;ate\u0026rdquo;, \u0026ldquo;nat\u0026rdquo;, \u0026ldquo;bat\u0026rdquo;] 输出: [[\u0026ldquo;bat\u0026rdquo;],[\u0026ldquo;nat\u0026rdquo;,\u0026ldquo;tan\u0026rdquo;],[\u0026ldquo;ate\u0026rdquo;,\u0026ldquo;eat\u0026rdquo;,\u0026ldquo;tea\u0026rdquo;]]\n示例 2: 输入: strs = [\u0026quot;\u0026quot;] 输出: [[\u0026quot;\u0026quot;]]\n示例 3: 输入: strs = [\u0026ldquo;a\u0026rdquo;] 输出: [[\u0026ldquo;a\u0026rdquo;]]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; groupAnagrams(vector\u0026lt;string\u0026gt;\u0026amp; strs) { unordered_map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; mp; for(string\u0026amp; str:strs){ string key =str; sort(key.begin(),key.end()); mp[key].emplace_back(str); } vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; ans; for(auto it = mp.begin();it!=mp.end();++it){ ans.emplace_back(it-\u0026gt;second); } return ans; } }; 解法 接着使用unordered_map 前边是排序后的字符串，后边是为排序的字符串，然后打印出来\n","date":"2025-03-07T00:00:00Z","image":"http://localhost:1313/p/hot-100/bfa716fb67d4d01aae4393a7de1d4effc73b6ba2_hu12973939456545149209.png","permalink":"http://localhost:1313/p/hot-100/","title":"LeetCode 热题 100 (1)"},{"content":"1. 两数之和 简单\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案。\n示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2]\n示例 3： 输入：nums = [3,3], target = 6 输出：[0,1]\n两数之和\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int,int\u0026gt;hash_map; for(int i=0;i\u0026lt;nums.size();i++) { auto it =hash_map.find(target-nums[i]); if(it !=hash_map.end()) { return {it-\u0026gt;second,i}; } hash_map[nums[i]]=i; } return{}; } }; 解法 使用unordered_map对数组进行遍历，查看另一半是否在unordered_map中，不在就加入，存在就返回\n49. 字母异位词分组 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\n示例 1: 输入: strs = [\u0026ldquo;eat\u0026rdquo;, \u0026ldquo;tea\u0026rdquo;, \u0026ldquo;tan\u0026rdquo;, \u0026ldquo;ate\u0026rdquo;, \u0026ldquo;nat\u0026rdquo;, \u0026ldquo;bat\u0026rdquo;] 输出: [[\u0026ldquo;bat\u0026rdquo;],[\u0026ldquo;nat\u0026rdquo;,\u0026ldquo;tan\u0026rdquo;],[\u0026ldquo;ate\u0026rdquo;,\u0026ldquo;eat\u0026rdquo;,\u0026ldquo;tea\u0026rdquo;]]\n示例 2: 输入: strs = [\u0026quot;\u0026quot;] 输出: [[\u0026quot;\u0026quot;]]\n示例 3: 输入: strs = [\u0026ldquo;a\u0026rdquo;] 输出: [[\u0026ldquo;a\u0026rdquo;]]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; groupAnagrams(vector\u0026lt;string\u0026gt;\u0026amp; strs) { unordered_map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; mp; for(string\u0026amp; str:strs){ string key =str; sort(key.begin(),key.end()); mp[key].emplace_back(str); } vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; ans; for(auto it = mp.begin();it!=mp.end();++it){ ans.emplace_back(it-\u0026gt;second); } return ans; } }; 解法 接着使用unordered_map 前边是排序后的字符串，后边是为排序的字符串，然后打印出来\n","date":"2025-03-07T00:00:00Z","image":"http://localhost:1313/p/hot-100/bfa716fb67d4d01aae4393a7de1d4effc73b6ba2_hu12973939456545149209.png","permalink":"http://localhost:1313/p/hot-100/","title":"LeetCode 热题 100 (1)"},{"content":"词法分析的基本功能 单词 保留字\u0026mdash;while,do（确定有限的\n标识符\u0026mdash;number1\n常量\u0026mdash;10,true\n特殊符号\u0026mdash;运算符，界限符，格式符（确定有限的\n正则表达式\u0026ndash;自动机 字母表\u0026ndash;元素的非空又穷集合\n符号串\u0026ndash;由字母表组成的有穷序列\n符号串的连接\u0026ndash;符号串的方幂\u0026ndash;符号串集合的乘积\u0026ndash;符号串集合的方幂\u0026ndash;符号串集合的正闭包\u0026ndash;符号串集合的星闭包（带空）\n正则表达式定义\n正则表达式的性质\n运算的优先级，|的交换性与结合性，幂的等价性，同一率\n用正则表达式描述词法\n作业 1.包含偶数个x的所有符号串。\n(y∣z)∗(xx(y∣z)∗)∗|x(y|z)x\n2、不包含连续两个y的所有符号串集合。\n(x∣z∣y(x∣z))∗y?\n","date":"2025-03-07T00:00:00Z","image":"http://localhost:1313/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/8a57cba2471e8a2495fb97fc0c03d9ac26dfa064_hu12112544462945716839.jpg","permalink":"http://localhost:1313/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","title":"编译原理"}]