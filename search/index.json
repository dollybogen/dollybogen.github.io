[{"content":"背景 16年ICDM ccf b\n北京大学王乐业\n基础介绍 目的：减少差异位置混淆造成的数据质量损失\n三个组件：数据调整函数，将原始传感数据拟合到模糊的位置。线性规划来选择一个最优的位置模糊函数，旨在最小化数据调整中的不确定性。提出了一种不确定性推理算法，以提高模糊数据的推理精度体。\nmcs——\u0026gt;稀疏mcs：目标感测区域有时可能太大，以至于难以获得移动用户的足够空间覆盖-\u0026gt;位置隐私\nlbs-\u0026gt;位置混淆（我的论文本质上是位置混淆），匿名化\n混淆——\u0026gt;伪装：用户的位置表示为包含多个细粒度单元格的隐藏区域，缺点：先验知识很致命-\u0026gt;引入差分隐私\n传统lbs位置混淆是由距离来测定相似，的王乐业以数据差异来测定“只要两个位置的感测值足够接近，参与者的位置就可以被映射到很远的地方”不合理（我的论文以tran来测定相似）\n三个平衡要素：参与者的隐私要求、对手对参与者实际位置分布的先验知识，以及位置混淆导致的数据质量下降\n隐私保护框架，由三个部分组成：（i）数据调整功能，使原始传感数据适应模糊的位置；（ii）最优混淆函数DUM-e及其快速近似值FDUM-e，以在差分隐私和均匀分布混淆的约束下最小化数据调整的不确定性；以及（iii）不确定性推理算法，以提高模糊数据的推理精度。\n背景介绍 稀疏MCS用例，收集的感知矩阵（矩阵完成问题），数据推理算法（压缩感知）\n压缩感知两个理论假设：1.感测区域应均匀分布，2，总推理误差与采样条目的不确定性水平成正比\n位置隐私-预留框架 位置隐私保护框架，包含两个组件：位置模糊和数据调整\n服务器端以离线方式生成概率混淆矩阵和数据调整函数。该矩阵对将任何一个区域混淆到另一个区域的概率进行编码。数据调整功能用于减少由于区域混淆导致的数据不确定性。\n客户端流程：下载矩阵，混淆位置，数据调整，上传数据\u0026mdash;-服务器补全\n差分位置隐私 对抗模型：贝叶斯攻击：假设对手对用户实际区域r的概率分布有一些先验知识，对手观察到用户的模糊区域r∗，他可以根据贝叶斯规则预测用户位置的后验分布，记为σ（r）\n备注：对轨迹攻击的研究将是我们未来的工作\n我们在稀疏MCS中定义差分隐私的目的是将对手的后验知识的改进限制在先验知识之上，即σ（r）/π（r）\ne差分隐私定义：e越小，保护程度越强，越接近平均\n限制了先前对手模型中的知识增益，即σ（r）/π（r），无论对手的先验知识π（r）的值是多少\n后验知识定义\n降低数据质量损失的差分位置隐私 混淆的数据质量要求：压缩感知要求：1.参与者从均匀分布的区域报告，2。他们报告的感知数据是准确的\n实际上：模糊区域的分布可能是不平衡的，虽然调整过依然存在一些不确定性\n最优模糊矩阵生成：我们试图降低数据的不确定性（使用混淆矩阵最小化数据不确定性预期），并控制位置模糊中产生的模糊区域的分布均匀性（混淆矩阵中引入了均匀性约束）\n目标：数据不确定性最小化\n服务器上进行线性回归模型学习，而在移动客户端上进行线性拟合估计\n定义了一个不确定性矩阵U来表示所提出的数据调整模型的内在误差或不确定性\n目标：最小化U中数据不确定性的总体期望\n约束：均匀模糊区域分布模糊区域需要均匀分布\n线性优化：DUM-e，实质是一个满足约束的一个线性优化问题\n","date":"2025-03-13T00:00:00Z","image":"http://localhost:1313/p/16%E5%B9%B4%E8%AE%BA%E6%96%87/87c0e1284db0589bd3eaf124fb7d4d0eac0d489b_hu6550907142862053687.png","permalink":"http://localhost:1313/p/16%E5%B9%B4%E8%AE%BA%E6%96%87/","title":"16年论文"},{"content":"绪论 希亚。拉博夫旗帜定位事件\n群智感知计算的定义，碎片化，低质冗余\n发展历程 从众包，参与感知发展而来\n数据来源方式为机会式感知和参与式感知\n任务的生命周期：发布任务，执行任务，数据汇聚，结果移交\n需要适用于动态数据流的优质数据挑选策略\n研究内容：感知任务分配与激励机制，感知数据的优选，群志感知隐私保护，感知数据的高效移交，群智感知计算的创新应用\n","date":"2025-03-13T00:00:00Z","image":"http://localhost:1313/p/%E7%BE%A4%E6%99%BA%E6%84%9F%E7%9F%A5%E8%AE%A1%E7%AE%97/87c0e1284db0589bd3eaf124fb7d4d0eac0d489b_hu6550907142862053687.png","permalink":"http://localhost:1313/p/%E7%BE%A4%E6%99%BA%E6%84%9F%E7%9F%A5%E8%AE%A1%E7%AE%97/","title":"群智感知计算"},{"content":"瀑布模型——\u0026gt;v模型\n原型/快速原型模型 实际可以运行的一个模型，和瀑布模型相比没有反馈环\n阶段是开发，演化模型 增量开发，迭代开发\n增量模型 每个组件一个一个的完成\n螺旋模型 原型模型上每一个步骤添加一个风险分析的过程\n喷泉模型 上下两层之间存在交叠\nRUP 开发经验：迭代式开发，使用用例和脚本，使用基于组件的架构，可视化建模\n软件开发的生命周期，先期阶段，细化阶段，构造阶段，移交阶段（横轴，10，30，50，10时间使用比\ninception,elaboration,construction,transition\n迭代，1，2，3，2\nworker，activity，artifact，workflow\n9个核心工作流\n架构师，分析师\n敏捷过程 4个价值观和12个原则\n极限编程，user story\n极限编程的迭代过程\n微软过程，考虑存在不确定因素，应具有稳定性，微软软件生命周期\n规划阶段，设计阶段，开发阶段，稳定阶段，发布阶段\n可行性研究的任务 逻辑模型：数据流图，数据字典\n技术可行性，经济可行性，操作可行性，法律可行性，开发方案的选择性研究\n系统流程图 dfd的符号：数据流，文件。dfd订货系统的例子。基本系统模型-\u0026gt;功能级数据流图\n分层数据流图 父图和子图的平衡问题\n局部文件的问题\n分解的深度和层次问题\n命名问题\n数据流图的用途\n数据字典 数据流条目\n数据元素条目描述\n结构化英语\n数据流分析实例 需求分析 功能性需求，系统质量，约束\n","date":"2025-03-11T00:00:00Z","image":"http://localhost:1313/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%8E%8B%E7%BC%A9%E7%89%88%20%281%29_hu16432260384076378747.png","permalink":"http://localhost:1313/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","title":"软件工程"},{"content":"1. 两数之和 简单\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案。\n示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2]\n示例 3： 输入：nums = [3,3], target = 6 输出：[0,1]\n两数之和\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int,int\u0026gt;hash_map; for(int i=0;i\u0026lt;nums.size();i++) { auto it =hash_map.find(target-nums[i]); if(it !=hash_map.end()) { return {it-\u0026gt;second,i}; } hash_map[nums[i]]=i; } return{}; } }; 解法 使用unordered_map对数组进行遍历，查看另一半是否在unordered_map中，不在就加入，存在就返回\n49. 字母异位词分组 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\n示例 1: 输入: strs = [\u0026ldquo;eat\u0026rdquo;, \u0026ldquo;tea\u0026rdquo;, \u0026ldquo;tan\u0026rdquo;, \u0026ldquo;ate\u0026rdquo;, \u0026ldquo;nat\u0026rdquo;, \u0026ldquo;bat\u0026rdquo;] 输出: [[\u0026ldquo;bat\u0026rdquo;],[\u0026ldquo;nat\u0026rdquo;,\u0026ldquo;tan\u0026rdquo;],[\u0026ldquo;ate\u0026rdquo;,\u0026ldquo;eat\u0026rdquo;,\u0026ldquo;tea\u0026rdquo;]]\n示例 2: 输入: strs = [\u0026quot;\u0026quot;] 输出: [[\u0026quot;\u0026quot;]]\n示例 3: 输入: strs = [\u0026ldquo;a\u0026rdquo;] 输出: [[\u0026ldquo;a\u0026rdquo;]]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; groupAnagrams(vector\u0026lt;string\u0026gt;\u0026amp; strs) { unordered_map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; mp; for(string\u0026amp; str:strs){ string key =str; sort(key.begin(),key.end()); mp[key].emplace_back(str); } vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; ans; for(auto it = mp.begin();it!=mp.end();++it){ ans.emplace_back(it-\u0026gt;second); } return ans; } }; 解法 接着使用unordered_map 前边是排序后的字符串，后边是为排序的字符串，然后打印出来\n128. 最长连续序列 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n请你设计并实现时间复杂度为 O(n) 的算法解决此问题。\n示例 1： 输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n示例 2： 输入：nums = [0,3,7,2,5,8,4,6,0,1] 输出：9\n示例 3： 输入：nums = [1,0,1,2] 输出：3\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int longestConsecutive(vector\u0026lt;int\u0026gt;\u0026amp; nums) { unordered_set\u0026lt;int\u0026gt; set; for(const int\u0026amp; num :nums){ set.insert(num); } int l=0; for(const int \u0026amp;num:set){ if(!set.count(num-1)){ int temp=num; int now =1; while(set.count(temp+1)){ now+=1; temp+=1; } l=max(l,now); } } return l; } }; 解法 先使用unordered_set去重，然后遍历set，只有处于第一位（n-1不存在）进入队列长度的计量。时间复杂度是O（n）\n283. 移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n示例 1: 输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0]\n示例 2: 输入: nums = [0] 输出: [0]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: void moveZeroes(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int a=0,b=0; for(int i=0;i\u0026lt;nums.size();i++) { if(nums[b]!=0) { nums[a]=nums[b]; a++; b++; } else { b++; } } for(;a \u0026lt; nums.size();a++) { nums[a]=0; } } }; 解法 双指针，一前一后，同时记录0的数量在最后给他补上（代码里好像没b什么事）\n11. 盛最多水的容器 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n返回容器可以储存的最大水量。\n说明：你不能倾斜容器。\n示例 1： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n示例 2： 输入：height = [1,1] 输出：1\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int l =0,r=height.size()-1; int ans=0; while(l\u0026lt;r){ int area=min(height[l],height[r])*(r-l); ans=max(ans,area); if(height[l]\u0026lt;=height[r]){ l++; } else{ r--; } } return ans; } }; 解法 使用双指针，从两边接近中间，偏小的一边前进，同时记录之间最大的面积\n证明：因为高板前进必然会导致结果的减小，使用只能前进短板，同时排除一部分结果\nx x x x x o x o o x x o x x x o o x x x x 160. 相交链表 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n图示两个链表在节点 c1 开始相交：\n题目数据 保证 整个链式结构中不存在环。\n注意，函数返回结果后，链表必须 保持其原始结构 。\n示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at \u0026lsquo;8\u0026rsquo;\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 — 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if(headA==nullptr||headB==nullptr) { return nullptr; } ListNode *pa=headA, *pb=headB; while(pa!=pb) { pa = pa == nullptr ? headB : pa-\u0026gt;next; pb = pb == nullptr ? headA : pb-\u0026gt;next; } return pa; }; }; 解法 使用两个指针，分别类似倒8字遍历两条链，直到相交或者都为空（无相交）\n证明：a+c+b==b+c+a\n206. 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例 1： 输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1]\n示例 2： 输入：head = [1,2] 输出：[2,1]\n示例 3： 输入：head = [] 输出：[]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* nex=head; ListNode* now=nullptr; ListNode* temp; while(nex!=nullptr) { temp=nex-\u0026gt;next; nex-\u0026gt;next=now; now=nex; nex=temp; } return now; } }; 解法 使用三个指针，两个负责反向，一个负责指向下一个位置\n234. 回文链表 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。\n示例 1： 输入：head = [1,2,2,1] 输出：true\n示例 2： 输入：head = [1,2] 输出：false\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: bool isPalindrome(ListNode* head) { int x[50110]; int num=0; while(head!=null) { x[num]=head-\u0026gt;val; head=head-\u0026gt;next; num++; } for(int i=0,j=num-1;i\u0026lt;j;i++,j--) { if(x[i]!=x[j]) { return false; } } return true; } }; 解法 用数组将链表读取，然后双指针一左一右对进判断，时间复杂度O（n）\n141. 环形链表 给你一个链表的头节点 head ，判断链表中是否有环。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。\n如果链表中存在环 ，则返回 true 。 否则，返回 false 。\n示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。\n示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。\n示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: bool hasCycle(ListNode *head) { unordered_set\u0026lt;ListNode*\u0026gt; hash; while(head!=nullptr) { if(hash.count(head)) { return true; } hash.insert(head); head=head-\u0026gt;next; } return false; } }; 解法 使用unordered_set,对每个加入的节点搜索，看看有没有一样的（使用数组一样的，只是时间复杂度会高\n21. 合并两个有序链表 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n示例 1： 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4]\n示例 2： 输入：l1 = [], l2 = [] 输出：[]\n示例 3： 输入：l1 = [], l2 = [0] 输出：[0]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) { struct ListNode* head; struct ListNode* p; if(list1==NULL\u0026amp;\u0026amp;list2==NULL) { return NULL; } if(list1!=NULL\u0026amp;\u0026amp;list2==NULL) { return list1; } if(list2!=NULL\u0026amp;\u0026amp;list1==NULL) { return list2; } if(list1-\u0026gt;val\u0026gt;=list2-\u0026gt;val) { head=list2; p=list2; list2=list2-\u0026gt;next; } else { head=list1; p=list1; list1=list1-\u0026gt;next; } while((list1!=NULL)||(list2!=NULL)) { if(list1==NULL\u0026amp;\u0026amp;list2!=NULL) { p-\u0026gt;next=list2; list2=list2-\u0026gt;next; p=p-\u0026gt;next; break; } if(list2==NULL\u0026amp;\u0026amp;list1!=NULL) { p-\u0026gt;next=list1; list1=list1-\u0026gt;next; p=p-\u0026gt;next; break; } if(list1-\u0026gt;val\u0026gt;=list2-\u0026gt;val) { p-\u0026gt;next=list2; list2=list2-\u0026gt;next; p=p-\u0026gt;next; } else { p-\u0026gt;next=list1; list1=list1-\u0026gt;next; p=p-\u0026gt;next; } } return head; } 解法 极度丑陋的代码，主要部分是维护三个指针，两个分别指着a，b，一个指着目标。但是需要考虑空，就需要超级多的if，else语句\n94. 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\n示例 1： 输入：root = [1,null,2,3] 输出：[1,3,2]\n示例 2： 输入：root = [] 输出：[]\n示例 3： 输入：root = [1] 输出：[1]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: void inorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root==nullptr) { return; } inorder(root-\u0026gt;left,res); res.push_back(root-\u0026gt;val); inorder(root-\u0026gt;right,res); } vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; inorder(root,res); return res; } }; 解法 传入一个栈，用res.push_back(root-\u0026gt;val);压入\n104. 二叉树的最大深度 给定一个二叉树 root ，返回其最大深度。\n二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。\n示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：3\n示例 2： 输入：root = [1,null,2] 输出：2\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int deep (TreeNode* root,int d) { if(root==nullptr) { return d; } int l=deep(root-\u0026gt;left,d+1); int r=deep(root-\u0026gt;right,d+1); if(l\u0026gt;=r) { return l; } else{ return r; } } int maxDepth(TreeNode* root) { int i=deep(root,0); return i; } }; 解法 二叉树大部分用的都是递归，取左+取右，比较\n226. 翻转二叉树 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\n示例 1： 输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1]\n示例 2： 输入：root = [2,1,3] 输出：[2,3,1]\n示例 3： 输入：root = [] 输出：[]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: TreeNode* invertTree(TreeNode* root) { if(root==nullptr) return nullptr; TreeNode *temp=root-\u0026gt;left; invertTree(root-\u0026gt;left); invertTree(root-\u0026gt;right); root-\u0026gt;left=root-\u0026gt;right; root-\u0026gt;right=temp; return root; } }; 解法 二叉树大部分用的都是递归，左子树先换，右子树再换，最后在根节点换\n101. 对称二叉树 给你一个二叉树的根节点 root ， 检查它是否轴对称。\n示例 1： 输入：root = [1,2,2,3,4,4,3] 输出：true\n示例 2： 输入：root = [1,2,2,null,3,null,3] 输出：false\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: bool fx(TreeNode* left,TreeNode* right){ if(left==nullptr\u0026amp;\u0026amp;right==nullptr){ return true; } if(left==nullptr\u0026amp;\u0026amp;right!=nullptr){ return false; } if(left!=nullptr\u0026amp;\u0026amp;right==nullptr){ return false; } if(left-\u0026gt;val==right-\u0026gt;val){ int a=fx(left-\u0026gt;left,right-\u0026gt;right); int b=fx(left-\u0026gt;right,right-\u0026gt;left); if(a==true\u0026amp;\u0026amp;b==true){ return true; } else{ return false; } } return false; } bool isSymmetric(TreeNode* root) { return fx(root-\u0026gt;left,root-\u0026gt;right); } }; 解法 二叉树大部分用的都是递归，传入左右两个节点，对称的来比较\n","date":"2025-03-07T00:00:00Z","image":"http://localhost:1313/p/hot-100/bfa716fb67d4d01aae4393a7de1d4effc73b6ba2_hu12973939456545149209.png","permalink":"http://localhost:1313/p/hot-100/","title":"LeetCode 热题 100 (1)"},{"content":"词法分析的基本功能 单词 保留字\u0026mdash;while,do（确定有限的\n标识符\u0026mdash;number1\n常量\u0026mdash;10,true\n特殊符号\u0026mdash;运算符，界限符，格式符（确定有限的\n正则表达式\u0026ndash;自动机 字母表\u0026ndash;元素的非空又穷集合\n符号串\u0026ndash;由字母表组成的有穷序列\n符号串的连接\u0026ndash;符号串的方幂\u0026ndash;符号串集合的乘积\u0026ndash;符号串集合的方幂\u0026ndash;符号串集合的正闭包\u0026ndash;符号串集合的星闭包（带空）\n正则表达式定义\n正则表达式的性质\n运算的优先级，|的交换性与结合性，幂的等价性，同一率\n用正则表达式描述词法\n作业 1.包含偶数个x的所有符号串。\n(y∣z)∗(xx(y∣z)∗)∗|x(y|z)x\n2、不包含连续两个y的所有符号串集合。\n(x∣z∣y(x∣z))∗y?\n第三节课 确定有限自动机 DFA，（求和符号，s，s0，Z，f）\n求和符号=字母表，s=状态集合，f=状态准换函数，s0=初始状态，Z=终止状态集合\n非确定有限自动机 NFA，s0初始状态集，存在空，转化函数可以到一个集合\n词法分析 自动机的最小化 定义：等价状态，无关状态\ndfa到正则表达式，正则表达式到nfa\n词法分析器的设计 token样例 类型+内容\n语法与文法 语法，语义，语用\n巴克斯范式BNF 语法成分::=组成成分\n赋值语句::=变量=表达式\n上下文无关文法 语法符号-\u0026gt;X1,X2\u0026hellip;\u0026hellip;\n文法G定义为四元组（Vt,Vn,P,S）\n终极符\n句型:从开始符推出来的，句子，语言\n验证程序是不是语法的句子\n语法树，句柄，直接左递归，直接右递归，最左推导，最右推导\n","date":"2025-03-07T00:00:00Z","image":"http://localhost:1313/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/8a57cba2471e8a2495fb97fc0c03d9ac26dfa064_hu12112544462945716839.jpg","permalink":"http://localhost:1313/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","title":"编译原理"},{"content":"线性筛素数 题目描述 如题，给定一个范围 n，有 q 个询问，每次输出第 k 小的素数。\n输入格式 第一行包含两个正整数 n,q，分别表示查询的范围和查询的个数。\n接下来 q 行每行一个正整数 k，表示查询第 k 小的素数。\n输出格式 输出 q 行，每行一个正整数表示答案。\n示例 1： 输入 #1复制 100 5 1 2 3 4 5 输出 #1复制 2 3 5 7 11\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { int n, q, a; int x[1001000]; bool y[100100000] = {0}; int t = 0; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;q); for (int i = 2; i \u0026lt;= n; i++) { if (!y[i]) { x[t++] = i; } for (int j = 0; j \u0026lt; t \u0026amp;\u0026amp; i * x[j] \u0026lt;= n; j++) { y[i * x[j]] = 1; if (i % x[j] == 0) break; } } for (int i = 0; i \u0026lt; q; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); if (a \u0026lt;= 0 || a \u0026gt; t) { printf(\u0026#34;Invalid input\\n\u0026#34;); } else { printf(\u0026#34;%d\\n\u0026#34;, x[a - 1]); // 改成0-based索引 } } return 0; } 解法 欧拉筛，线性筛，总体思路是先筛2（最多两倍），然后读入一个素数，然后再筛2，3（最多3倍），然后读入一个素数，这样一直添加。可以保证添加的一定为素数\n模板 快速幂 给你三个整数 a,b,p，求 a b mod p。\n输入格式 输入只有一行三个整数，分别代表 a,b,p。\n输出格式 输出一行一个字符串 a^b mod p=s，其中 a,b,p 分别为题目给定的值， s 为运算结果。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; long long x[47483648] = {}; long long fx(long long a, long long b, long long p) { long long lld, e; if (b == 1) return a % p; long long c = b / 2; if (c\u0026lt; 47483648\u0026amp;\u0026amp;x[c] != 0) lld = x[c]; else lld = fx(a, c, p); if(b\u0026lt; 47483648) x[b] = lld * e % p; return lld * e % p; } int main() { long long a, b, c, lld, p, s; scanf(\u0026#34;%lld %lld %lld\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;p); c = fx(a, b, p); printf(\u0026#34;%lld^%lld mod %lld=%lld\u0026#34;, a, b, p, c); return 0; } 解法 一定要long long 不然中途回爆炸，将幂转换成二进制使用，维护一个答案，当幂上出现奇数的时候对答案乘上一个base，然后将base幂一下，幂指数b也除以二\n括号配对II 高级语言程序设计中的各种括号应该匹配，例如：“(” 与 “)”匹配、“[”与 “]” 匹配、“{”与 “}” 匹配等。 输入一字符文件，判断其中的括号是否匹配。假设括号没有优先级差别。\n输入格式: 多行，字符个数不超过 65536。\n输出格式: 一个单词，表示字符文件中括号匹配的结果，匹配输出“yes”，否则输出“no”.\n输入样例: 在这里给出一组输入。例如：\n( { } ) {a=(b*c)+free( ) }。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;stdio.h\u0026gt; char x[1000]={\u0026#39;#\u0026#39;}; int main(void) { int a = 1, b = 1, c, d; char ch; while (scanf(\u0026#34;%c\u0026#34;,\u0026amp;ch)!=EOF) { if (ch == \u0026#39;(\u0026#39; || ch == \u0026#39;{\u0026#39; || ch == \u0026#39;[\u0026#39;) { x[a] = ch; a++; } if (ch == \u0026#39;)\u0026#39;) { if (x[a - 1] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; a \u0026gt;= 1) { a--; x[a] = 0; } else { b = 0; break; } } if (ch == \u0026#39;]\u0026#39;) { if (x[a - 1] == \u0026#39;[\u0026#39; \u0026amp;\u0026amp; a \u0026gt;= 1) { a--; x[a] = 0; } else { b = 0; break; } } if (ch == \u0026#39;}\u0026#39;) { if (x[a - 1] == \u0026#39;{\u0026#39;\u0026amp;\u0026amp;a\u0026gt;=1) { a--; x[a] = 0; } else { b = 0; break; } } } if (b == 0 || a != 1) printf(\u0026#34;no\u0026#34;); else printf(\u0026#34;yes\u0026#34;); return 0; } 解法 使用栈结构，使用while (scanf(\u0026quot;%c\u0026quot;,\u0026amp;ch)!=EOF)来判断是否还有输入\nBlah数集 大数学家高斯小时候偶然发现一种有趣的自然数集合Blah。以a为基的集合Ba定义如下：\na是集合Ba的基，且a是Ba的第一个元素； 若x在集合Ba中，则2x+1和3x+1也都在Ba中； 没有其它元素在集合Ba中。 现在小高斯想知道如果将集合Ba中元素按照升序排列，第n个元素会是多少？ 输入格式: 多行，每行包括两个数，集合的基a(1\u0026lt;=a\u0026lt;=50))以及所求元素序号n(1\u0026lt;=n\u0026lt;=1000000)\n输出格式: 对于每个输入，输出集合Ba的第n个元素值\n输入样例: 在这里给出一组输入。例如：\n1 5 25 100000\n输出样例: 在这里给出相应的输出。例如：\n9 34503679\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;stdio.h\u0026gt; long long x[1000000]; int main(void) { long long a = 0, b = 0, c = 1, n, i; while (scanf(\u0026#34;%lld %lld\u0026#34;, \u0026amp;i, \u0026amp;n) != EOF) { x[0] = i; a = 0; b = 0; for (c = 1; c \u0026lt;= n; c++) { if ((x[a] * 2 + 1 == x[b] * 3 + 1)) { x[c] = x[a] * 2 + 1; a++; b++; } else if (x[a] * 2 + 1 \u0026lt; x[b] * 3 + 1) { x[c] = x[a] * 2 + 1; a++; } else { x[c] = x[b] * 3 + 1; b++; } } printf(\u0026#34;%lld\\n\u0026#34;, x[n-1]); } } 解法 维护2x+1与3x+1两个指针，都大于已有的最后一个数，然后比较，添加进入。\n左侧最近小数 对N个非负整数的序列，查询元素A i左侧最近的小于A i ​ 的整数(1≤i≤N)，如果不存在，输出 -1\n输入格式: 第1行，1个整数N，表示整数的个数，(1≤N≤100000)。\n第2行，N个整数，每个整数x 都满足 0 ≤ x ≤2000000000。\n输出格式: 1行,N个整数，表示每个元素A i ​ 左侧最近的小于A i ​ 的整数(1≤i≤N)。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; long long x[100000] = {-1}; int main(void) { long long a, b=0, c, d, n, i; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for (a = 0; a \u0026lt; n; a++) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;i); for (; x[b] \u0026gt;= i;b--) { x[b] = 0; } if (i \u0026gt; x[b]) { if(n-a!=1) printf(\u0026#34;%lld \u0026#34;, x[b]); else printf(\u0026#34;%lld\u0026#34;, x[b]); b++; x[b] = i; } } } 解法 维护一个单调栈，从左往右读，每次跟最上边比，大就入栈，小就弹栈再比\n区间最小值I 对N个整数的序列，从左到右连续查询 M 长度子序列 A i ​ ,A i+1 ​ ,\u0026hellip;,A i−M+1 ​ (1≤i，M≤N)的最小值。\n输入格式: 第1行，两个整数：N和M，表示整数的个数和区间长度，1≤N≤100000. 第2行，N个整数，每个整数x 都满足 │x│≤2000000000。\n输出格式: 1行, 用空格分隔的N-M+1个整数，对应从左到右所有连续M长度子序列的最小值。\n输入样例: 6 3 1 2 5 3 4 6 输出样例: 1 2 3 3 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;stdio.h\u0026gt; long long x[100000][2]; int main(void) { long long n, m, a, b, c = 0, d = 0, i; scanf(\u0026#34;%lld %lld\u0026#34;, \u0026amp;n, \u0026amp;m); for (a = 0; a \u0026lt; n; a++) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;i); for (b = c; b \u0026gt;= 0; b--) //单调性维护 { if (b == d || i \u0026gt; x[b - 1][0]) { x[b][0] = i; x[b][1] = a; c++; break; } else { x[b - 1][0] = 0; x[b - 1][1] = 0; c--; } } if (x[c - 1][1] - x[d][1] \u0026gt;= m) //区间维护 { x[d][1] = 0; x[d][0] = 0; d++; } if (a + 1 \u0026gt;= m) { if(n-a!=1) printf(\u0026#34;%lld \u0026#34;, x[d][0]); else printf(\u0026#34;%lld\u0026#34;, x[d][0]); } } } 解法 使用两个数组，一个存数字，一个存下标，一个移动的指针指向最小，只有递增的加入队列，左指针随着移动，分为单调性维护和区间维护\na+b高精度加法 高精度加法，相当于 a+b problem，不用考虑负数。\n输入格式 分两行输入。a,b≤10 500 。\n输出格式 输出只有一行，代表 a+b 的值。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; char a[10010]; int x[10010]; int main(){ scanf(\u0026#34;%s\u0026#34;,\u0026amp;a); int n=strlen(a); for(int i=0;i\u0026lt;n;i++){ x[i]+=a[n-1-i]-\u0026#39;0\u0026#39;; } scanf(\u0026#34;%s\u0026#34;,\u0026amp;a); n=strlen(a); for(int i=0;i\u0026lt;n;i++){ x[i]+=a[n-1-i]-\u0026#39;0\u0026#39;; } for(int i=0;i\u0026lt;10000;i++){ x[i+1]+=x[i]/10; x[i]=x[i]%10; } int t=0; for(int i=10010;i\u0026gt;=0;i--){ if(x[i]!=0){ t=1; } if(t==1){ printf(\u0026#34;%d\u0026#34;,x[i]); } } if(t==0){ printf(\u0026#34;0\u0026#34;); } return 0; } 解法 用一个字符数组记录读入的数字，用一个数字数组翻转，再使用模10计算进位，最后从后往前打印，存在第一个非0的打印，0单独考虑\n[NOIP 2015 提高组] 跳石头 一年一度的“跳石头”比赛又要开始了！\n这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 N 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。\n为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 M 块岩石（不能移走起点和终点的岩石）\n输入格式 第一行包含三个整数 L,N,M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 L≥1 且 N≥M≥0。\n接下来 N 行，每行一个整数，第 i 行的整数 D i ​ (0\u0026lt;D i ​ \u0026lt;L)， 表示第 i 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。\n输出格式 一个整数，即最短跳跃距离的最大值。\n输入输出样例 输入 #1复制\n25 5 2 2 11 14 17 21 输出 #1复制\n4 说明/提示 输入输出样例 1 说明 将与起点距离为 2 和 14 的两个岩石移走后，最短的跳跃距离为 4（从与起点距离 17 的岩石跳到距离 21 的岩石，或者从距离 21 的岩石跳到终点）。\n数据规模与约定 对于 20%的数据，0≤M≤N≤10。 对于 50% 的数据，0≤M≤N≤100。 对于 100% 的数据，0≤M≤N≤50000,1≤L≤10 9 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;cstdio\u0026gt; int k,n,m; int pos[50005]; bool check(int mid){ int ans=0,st=0; for(int i=1;i\u0026lt;=n;++i) if(pos[i]-st\u0026lt;mid) ans=ans+1; else st=pos[i]; return ans\u0026lt;=m; } int main(){ scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;k,\u0026amp;n,\u0026amp;m); for(int i=1;i\u0026lt;=n;++i)scanf(\u0026#34;%d\u0026#34;,\u0026amp;pos[i]); int l=0,r=k,mid; while(l\u0026lt;r){ mid=(l+r)\u0026gt;\u0026gt;1; if(check(mid))l=mid+1; else r=mid-1; } if(!check(l))l-=1; printf(\u0026#34;%d\\n\u0026#34;,l); return 0; } 解法 枚举答案，然后判断答案是否正确，对枚举的答案先进行判断，然后进行二分。\n141. 【深基13.例1】查找 题目描述 输入 n 个不超过 10 9 的单调不减的（就是后面的数字不小于前面的数字）非负整数 a 1 ​ ,a 2 ​ ,…,a n ​ ，然后进行 m 次询问。对于每次询问，给出一个整数 q，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 −1 。\n输入格式 第一行 2 个整数 n 和 m，表示数字个数和询问次数。\n第二行 n 个整数，表示这些待查询的数字。\n第三行 m 个整数，表示询问这些数字的编号，从 1 开始编号。\n输出格式 输出一行，m 个整数，以空格隔开，表示答案。\n输入输出样例 输入 #1复制\n11 3 1 3 3 3 5 7 9 11 13 15 15 1 3 6 输出 #1复制\n1 2 -1 说明/提示 数据保证，1≤n≤10 6 ，0≤a i ​ ,q≤10 9 ，1≤m≤10 5\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;math.h\u0026gt; int x[1001000]; int main(){ int n,m,q; int l,r,mid,p; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=0;i\u0026lt;n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;x[i]); } for(int i=0;i\u0026lt;m;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;q); l=0; p=0; r=n-1; while(l\u0026lt;=r){ mid=(l+r)/2; if(x[mid]==q){ p=mid; r=mid-1; } else if(x[mid]\u0026gt;q){ r=mid-1; } else if(x[mid]\u0026lt;q){ l=mid+1; } } if(x[p]!=q){ printf(\u0026#34;-1 \u0026#34;); continue; } else{ printf(\u0026#34;%d \u0026#34;,p+1); } } return 0; } 解法 使用二分法，从中间开始判断，mid+1，mid-1\n木材加工 题目背景 要保护环境\n题目描述 木材厂有 n 根原木，现在想把这些木头切割成 k 段长度均为 l 的小段木头（木头有可能有剩余）。\n当然，我们希望得到的小段木头越长越好，请求出 l 的最大值。\n木头长度的单位是 cm，原木的长度都是正整数，我们要求切割得到的小段木头的长度也是正整数。\n例如有两根原木长度分别为 11 和 21，要求切割成等长的 6 段，很明显能切割出来的小段木头长度最长为 5。\n输入格式 第一行是两个正整数 n,k，分别表示原木的数量，需要得到的小段的数量。\n接下来 n 行，每行一个正整数 L i ​ ，表示一根原木的长度。\n输出格式 仅一行，即 l 的最大值。\n如果连 1cm 长的小段都切不出来，输出 0。\n输入输出样例 输入 #1复制\n3 7 232 124 456 输出 #1复制\n114 说明/提示 数据规模与约定 对于 100% 的数据，有 1≤n≤10 5 ，1≤k≤10 8 ，1≤L i ​ ≤10 8 (i∈[1,n])。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;stdio.h\u0026gt; #define MAX_N 100100 long long x[MAX_N]; int main() { int n, k; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;k); long long sum = 0; long long max_length = 0; // 读入木材长度，并计算总长度和最大长度 for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x[i]); sum += x[i]; if (x[i] \u0026gt; max_length) { max_length = x[i]; } } // 如果总长度不足以分成 k 段，直接返回 0 if (sum \u0026lt; k) { printf(\u0026#34;0\\n\u0026#34;); return 0; } long long low = 1; long long high = max_length; long long ans = 0; while (low \u0026lt;= high) { long long mid = (low + high) / 2; long long count = 0; // 计算以 mid 为长度可以切出多少段 for (int i = 0; i \u0026lt; n; i++) { count += x[i] / mid; if (count \u0026gt;= k) break; // 提前退出优化 } if (count \u0026gt;= k) { ans = mid; // 当前长度可行，尝试更大的长度 low = mid + 1; } else { high = mid - 1; } } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } 解法 倒着走，不去搜答案而是判断答案，然后通过二分法来加速过程\n94. 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\n示例 1： 输入：root = [1,null,2,3] 输出：[1,3,2]\n示例 2： 输入：root = [] 输出：[]\n示例 3： 输入：root = [1] 输出：[1]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: void inorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root==nullptr) { return; } inorder(root-\u0026gt;left,res); res.push_back(root-\u0026gt;val); inorder(root-\u0026gt;right,res); } vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; inorder(root,res); return res; } }; 解法 传入一个栈，用res.push_back(root-\u0026gt;val);压入\n104. 二叉树的最大深度 给定一个二叉树 root ，返回其最大深度。\n二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。\n示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：3\n示例 2： 输入：root = [1,null,2] 输出：2\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int deep (TreeNode* root,int d) { if(root==nullptr) { return d; } int l=deep(root-\u0026gt;left,d+1); int r=deep(root-\u0026gt;right,d+1); if(l\u0026gt;=r) { return l; } else{ return r; } } int maxDepth(TreeNode* root) { int i=deep(root,0); return i; } }; 解法 二叉树大部分用的都是递归，取左+取右，比较\n226. 翻转二叉树 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\n示例 1： 输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1]\n示例 2： 输入：root = [2,1,3] 输出：[2,3,1]\n示例 3： 输入：root = [] 输出：[]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: TreeNode* invertTree(TreeNode* root) { if(root==nullptr) return nullptr; TreeNode *temp=root-\u0026gt;left; invertTree(root-\u0026gt;left); invertTree(root-\u0026gt;right); root-\u0026gt;left=root-\u0026gt;right; root-\u0026gt;right=temp; return root; } }; 解法 二叉树大部分用的都是递归，左子树先换，右子树再换，最后在根节点换\n101. 对称二叉树 给你一个二叉树的根节点 root ， 检查它是否轴对称。\n示例 1： 输入：root = [1,2,2,3,4,4,3] 输出：true\n示例 2： 输入：root = [1,2,2,null,3,null,3] 输出：false\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: bool fx(TreeNode* left,TreeNode* right){ if(left==nullptr\u0026amp;\u0026amp;right==nullptr){ return true; } if(left==nullptr\u0026amp;\u0026amp;right!=nullptr){ return false; } if(left!=nullptr\u0026amp;\u0026amp;right==nullptr){ return false; } if(left-\u0026gt;val==right-\u0026gt;val){ int a=fx(left-\u0026gt;left,right-\u0026gt;right); int b=fx(left-\u0026gt;right,right-\u0026gt;left); if(a==true\u0026amp;\u0026amp;b==true){ return true; } else{ return false; } } return false; } bool isSymmetric(TreeNode* root) { return fx(root-\u0026gt;left,root-\u0026gt;right); } }; 解法 二叉树大部分用的都是递归，传入左右两个节点，对称的来比较\n","date":"0001-01-01T00:00:00Z","image":"http://localhost:1313/p/%E6%B4%9B%E8%B0%B7/e7037b88f726314190e4c31d32139470245f14a1_hu14003779742696075168.png","permalink":"http://localhost:1313/p/%E6%B4%9B%E8%B0%B7/","title":"洛谷"},{"content":"第一节课 课程介绍 机器学习的应用，生产，推荐，预测，无人车\n工作流程：问题，收集数据，训练，部署，监控\n预测值叫回归\n问题：将问题变成机器学习问题，缺高质量数据，训练模型贵，长期监控模型，公平性问题（由数据引发的）\n将人分类（四类）：领域专家，数据科学家，机器学习专家，sde（训练模型）\n","date":"0001-01-01T00:00:00Z","image":"http://localhost:1313/p/%E5%AE%9E%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/5140a2d84a36afa49b16afeb93ecff2773c78626_hu73922755549489808.png","permalink":"http://localhost:1313/p/%E5%AE%9E%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","title":"实用机器学习"}]