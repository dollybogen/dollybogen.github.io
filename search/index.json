[{"content":"绪论 希亚。拉博夫旗帜定位事件\n群智感知计算的定义，碎片化，低质冗余\n发展历程 从众包，参与感知发展而来\n数据来源方式为机会式感知和参与式感知\n任务的生命周期：发布任务，执行任务，数据汇聚，结果移交\n需要适用于动态数据流的优质数据挑选策略\n研究内容：感知任务分配与激励机制，感知数据的优选，群志感知隐私保护，感知数据的高效移交，群智感知计算的创新应用\n","date":"2025-03-13T00:00:00Z","image":"http://localhost:5029/p/%E7%BE%A4%E6%99%BA%E6%84%9F%E7%9F%A5%E8%AE%A1%E7%AE%97/87c0e1284db0589bd3eaf124fb7d4d0eac0d489b_hu6550907142862053687.png","permalink":"http://localhost:5029/p/%E7%BE%A4%E6%99%BA%E6%84%9F%E7%9F%A5%E8%AE%A1%E7%AE%97/","title":"群智感知计算"},{"content":"瀑布模型——\u0026gt;v模型\n原型/快速原型模型 实际可以运行的一个模型，和瀑布模型相比没有反馈环\n阶段是开发，演化模型 增量开发，迭代开发\n增量模型 每个组件一个一个的完成\n螺旋模型 原型模型上每一个步骤添加一个风险分析的过程\n喷泉模型 上下两层之间存在交叠\nRUP 开发经验：迭代式开发，使用用例和脚本，使用基于组件的架构，可视化建模\n软件开发的生命周期，先期阶段，细化阶段，构造阶段，移交阶段（横轴，10，30，50，10时间使用比\ninception,elaboration,construction,transition\n迭代，1，2，3，2\nworker，activity，artifact，workflow\n9个核心工作流\n架构师，分析师\n敏捷过程 4个价值观和12个原则\n极限编程，user story\n","date":"2025-03-11T00:00:00Z","image":"http://localhost:5029/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%8E%8B%E7%BC%A9%E7%89%88%20%281%29_hu16432260384076378747.png","permalink":"http://localhost:5029/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","title":"软件工程"},{"content":"1. 两数之和 简单\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案。\n示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2]\n示例 3： 输入：nums = [3,3], target = 6 输出：[0,1]\n两数之和\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int,int\u0026gt;hash_map; for(int i=0;i\u0026lt;nums.size();i++) { auto it =hash_map.find(target-nums[i]); if(it !=hash_map.end()) { return {it-\u0026gt;second,i}; } hash_map[nums[i]]=i; } return{}; } }; 解法 使用unordered_map对数组进行遍历，查看另一半是否在unordered_map中，不在就加入，存在就返回\n49. 字母异位词分组 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\n示例 1: 输入: strs = [\u0026ldquo;eat\u0026rdquo;, \u0026ldquo;tea\u0026rdquo;, \u0026ldquo;tan\u0026rdquo;, \u0026ldquo;ate\u0026rdquo;, \u0026ldquo;nat\u0026rdquo;, \u0026ldquo;bat\u0026rdquo;] 输出: [[\u0026ldquo;bat\u0026rdquo;],[\u0026ldquo;nat\u0026rdquo;,\u0026ldquo;tan\u0026rdquo;],[\u0026ldquo;ate\u0026rdquo;,\u0026ldquo;eat\u0026rdquo;,\u0026ldquo;tea\u0026rdquo;]]\n示例 2: 输入: strs = [\u0026quot;\u0026quot;] 输出: [[\u0026quot;\u0026quot;]]\n示例 3: 输入: strs = [\u0026ldquo;a\u0026rdquo;] 输出: [[\u0026ldquo;a\u0026rdquo;]]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; groupAnagrams(vector\u0026lt;string\u0026gt;\u0026amp; strs) { unordered_map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; mp; for(string\u0026amp; str:strs){ string key =str; sort(key.begin(),key.end()); mp[key].emplace_back(str); } vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; ans; for(auto it = mp.begin();it!=mp.end();++it){ ans.emplace_back(it-\u0026gt;second); } return ans; } }; 解法 接着使用unordered_map 前边是排序后的字符串，后边是为排序的字符串，然后打印出来\n128. 最长连续序列 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n请你设计并实现时间复杂度为 O(n) 的算法解决此问题。\n示例 1： 输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n示例 2： 输入：nums = [0,3,7,2,5,8,4,6,0,1] 输出：9\n示例 3： 输入：nums = [1,0,1,2] 输出：3\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int longestConsecutive(vector\u0026lt;int\u0026gt;\u0026amp; nums) { unordered_set\u0026lt;int\u0026gt; set; for(const int\u0026amp; num :nums){ set.insert(num); } int l=0; for(const int \u0026amp;num:set){ if(!set.count(num-1)){ int temp=num; int now =1; while(set.count(temp+1)){ now+=1; temp+=1; } l=max(l,now); } } return l; } }; 解法 先使用unordered_set去重，然后遍历set，只有处于第一位（n-1不存在）进入队列长度的计量。时间复杂度是O（n）\n283. 移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n示例 1: 输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0]\n示例 2: 输入: nums = [0] 输出: [0]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: void moveZeroes(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int a=0,b=0; for(int i=0;i\u0026lt;nums.size();i++) { if(nums[b]!=0) { nums[a]=nums[b]; a++; b++; } else { b++; } } for(;a \u0026lt; nums.size();a++) { nums[a]=0; } } }; 解法 双指针，一前一后，同时记录0的数量在最后给他补上（代码里好像没b什么事）\n11. 盛最多水的容器 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n返回容器可以储存的最大水量。\n说明：你不能倾斜容器。\n示例 1： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n示例 2： 输入：height = [1,1] 输出：1\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int l =0,r=height.size()-1; int ans=0; while(l\u0026lt;r){ int area=min(height[l],height[r])*(r-l); ans=max(ans,area); if(height[l]\u0026lt;=height[r]){ l++; } else{ r--; } } return ans; } }; 解法 使用双指针，从两边接近中间，偏小的一边前进，同时记录之间最大的面积\n证明：因为高板前进必然会导致结果的减小，使用只能前进短板，同时排除一部分结果\nx x x x x o x o o x x o x x x o o x x x x 160. 相交链表 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n图示两个链表在节点 c1 开始相交：\n题目数据 保证 整个链式结构中不存在环。\n注意，函数返回结果后，链表必须 保持其原始结构 。\n示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at \u0026lsquo;8\u0026rsquo;\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 — 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if(headA==nullptr||headB==nullptr) { return nullptr; } ListNode *pa=headA, *pb=headB; while(pa!=pb) { pa = pa == nullptr ? headB : pa-\u0026gt;next; pb = pb == nullptr ? headA : pb-\u0026gt;next; } return pa; }; }; 解法 使用两个指针，分别类似倒8字遍历两条链，直到相交或者都为空（无相交）\n证明：a+c+b==b+c+a\n206. 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例 1： 输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1]\n示例 2： 输入：head = [1,2] 输出：[2,1]\n示例 3： 输入：head = [] 输出：[]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* nex=head; ListNode* now=nullptr; ListNode* temp; while(nex!=nullptr) { temp=nex-\u0026gt;next; nex-\u0026gt;next=now; now=nex; nex=temp; } return now; } }; 解法 使用三个指针，两个负责反向，一个负责指向下一个位置\n234. 回文链表 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。\n示例 1： 输入：head = [1,2,2,1] 输出：true\n示例 2： 输入：head = [1,2] 输出：false\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: bool isPalindrome(ListNode* head) { int x[50110]; int num=0; while(head!=null) { x[num]=head-\u0026gt;val; head=head-\u0026gt;next; num++; } for(int i=0,j=num-1;i\u0026lt;j;i++,j--) { if(x[i]!=x[j]) { return false; } } return true; } }; 解法 用数组将链表读取，然后双指针一左一右对进判断，时间复杂度O（n）\n141. 环形链表 给你一个链表的头节点 head ，判断链表中是否有环。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。\n如果链表中存在环 ，则返回 true 。 否则，返回 false 。\n示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。\n示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。\n示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: bool hasCycle(ListNode *head) { unordered_set\u0026lt;ListNode*\u0026gt; hash; while(head!=nullptr) { if(hash.count(head)) { return true; } hash.insert(head); head=head-\u0026gt;next; } return false; } }; 解法 使用unordered_set,对每个加入的节点搜索，看看有没有一样的（使用数组一样的，只是时间复杂度会高\n21. 合并两个有序链表 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n示例 1： 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4]\n示例 2： 输入：l1 = [], l2 = [] 输出：[]\n示例 3： 输入：l1 = [], l2 = [0] 输出：[0]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) { struct ListNode* head; struct ListNode* p; if(list1==NULL\u0026amp;\u0026amp;list2==NULL) { return NULL; } if(list1!=NULL\u0026amp;\u0026amp;list2==NULL) { return list1; } if(list2!=NULL\u0026amp;\u0026amp;list1==NULL) { return list2; } if(list1-\u0026gt;val\u0026gt;=list2-\u0026gt;val) { head=list2; p=list2; list2=list2-\u0026gt;next; } else { head=list1; p=list1; list1=list1-\u0026gt;next; } while((list1!=NULL)||(list2!=NULL)) { if(list1==NULL\u0026amp;\u0026amp;list2!=NULL) { p-\u0026gt;next=list2; list2=list2-\u0026gt;next; p=p-\u0026gt;next; break; } if(list2==NULL\u0026amp;\u0026amp;list1!=NULL) { p-\u0026gt;next=list1; list1=list1-\u0026gt;next; p=p-\u0026gt;next; break; } if(list1-\u0026gt;val\u0026gt;=list2-\u0026gt;val) { p-\u0026gt;next=list2; list2=list2-\u0026gt;next; p=p-\u0026gt;next; } else { p-\u0026gt;next=list1; list1=list1-\u0026gt;next; p=p-\u0026gt;next; } } return head; } 解法 极度丑陋的代码，主要部分是维护三个指针，两个分别指着a，b，一个指着目标。但是需要考虑空，就需要超级多的if，else语句\n94. 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\n示例 1： 输入：root = [1,null,2,3] 输出：[1,3,2]\n示例 2： 输入：root = [] 输出：[]\n示例 3： 输入：root = [1] 输出：[1]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: void inorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root==nullptr) { return; } inorder(root-\u0026gt;left,res); res.push_back(root-\u0026gt;val); inorder(root-\u0026gt;right,res); } vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; inorder(root,res); return res; } }; 解法 传入一个栈，用res.push_back(root-\u0026gt;val);压入\n104. 二叉树的最大深度 给定一个二叉树 root ，返回其最大深度。\n二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。\n示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：3\n示例 2： 输入：root = [1,null,2] 输出：2\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int deep (TreeNode* root,int d) { if(root==nullptr) { return d; } int l=deep(root-\u0026gt;left,d+1); int r=deep(root-\u0026gt;right,d+1); if(l\u0026gt;=r) { return l; } else{ return r; } } int maxDepth(TreeNode* root) { int i=deep(root,0); return i; } }; 解法 二叉树大部分用的都是递归，取左+取右，比较\n226. 翻转二叉树 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\n示例 1： 输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1]\n示例 2： 输入：root = [2,1,3] 输出：[2,3,1]\n示例 3： 输入：root = [] 输出：[]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: TreeNode* invertTree(TreeNode* root) { if(root==nullptr) return nullptr; TreeNode *temp=root-\u0026gt;left; invertTree(root-\u0026gt;left); invertTree(root-\u0026gt;right); root-\u0026gt;left=root-\u0026gt;right; root-\u0026gt;right=temp; return root; } }; 解法 二叉树大部分用的都是递归，左子树先换，右子树再换，最后在根节点换\n101. 对称二叉树 给你一个二叉树的根节点 root ， 检查它是否轴对称。\n示例 1： 输入：root = [1,2,2,3,4,4,3] 输出：true\n示例 2： 输入：root = [1,2,2,null,3,null,3] 输出：false\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: bool fx(TreeNode* left,TreeNode* right){ if(left==nullptr\u0026amp;\u0026amp;right==nullptr){ return true; } if(left==nullptr\u0026amp;\u0026amp;right!=nullptr){ return false; } if(left!=nullptr\u0026amp;\u0026amp;right==nullptr){ return false; } if(left-\u0026gt;val==right-\u0026gt;val){ int a=fx(left-\u0026gt;left,right-\u0026gt;right); int b=fx(left-\u0026gt;right,right-\u0026gt;left); if(a==true\u0026amp;\u0026amp;b==true){ return true; } else{ return false; } } return false; } bool isSymmetric(TreeNode* root) { return fx(root-\u0026gt;left,root-\u0026gt;right); } }; 解法 二叉树大部分用的都是递归，传入左右两个节点，对称的来比较\n","date":"2025-03-07T00:00:00Z","image":"http://localhost:5029/p/hot-100/bfa716fb67d4d01aae4393a7de1d4effc73b6ba2_hu12973939456545149209.png","permalink":"http://localhost:5029/p/hot-100/","title":"LeetCode 热题 100 (1)"},{"content":"词法分析的基本功能 单词 保留字\u0026mdash;while,do（确定有限的\n标识符\u0026mdash;number1\n常量\u0026mdash;10,true\n特殊符号\u0026mdash;运算符，界限符，格式符（确定有限的\n正则表达式\u0026ndash;自动机 字母表\u0026ndash;元素的非空又穷集合\n符号串\u0026ndash;由字母表组成的有穷序列\n符号串的连接\u0026ndash;符号串的方幂\u0026ndash;符号串集合的乘积\u0026ndash;符号串集合的方幂\u0026ndash;符号串集合的正闭包\u0026ndash;符号串集合的星闭包（带空）\n正则表达式定义\n正则表达式的性质\n运算的优先级，|的交换性与结合性，幂的等价性，同一率\n用正则表达式描述词法\n作业 1.包含偶数个x的所有符号串。\n(y∣z)∗(xx(y∣z)∗)∗|x(y|z)x\n2、不包含连续两个y的所有符号串集合。\n(x∣z∣y(x∣z))∗y?\n第三节课 确定有限自动机 DFA，（求和符号，s，s0，Z，f）\n求和符号=字母表，s=状态集合，f=状态准换函数，s0=初始状态，Z=终止状态集合\n非确定有限自动机 NFA，s0初始状态集，存在空，转化函数可以到一个集合\n词法分析 自动机的最小化 定义：等价状态，无关状态\ndfa到正则表达式，正则表达式到nfa\n词法分析器的设计 token样例 类型+内容\n","date":"2025-03-07T00:00:00Z","image":"http://localhost:5029/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/8a57cba2471e8a2495fb97fc0c03d9ac26dfa064_hu12112544462945716839.jpg","permalink":"http://localhost:5029/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","title":"编译原理"},{"content":"1. 线性筛素数 题目描述 如题，给定一个范围 n，有 q 个询问，每次输出第 k 小的素数。\n输入格式 第一行包含两个正整数 n,q，分别表示查询的范围和查询的个数。\n接下来 q 行每行一个正整数 k，表示查询第 k 小的素数。\n输出格式 输出 q 行，每行一个正整数表示答案。\n示例 1： 输入 #1复制 100 5 1 2 3 4 5 输出 #1复制 2 3 5 7 11\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { int n, q, a; int x[1001000]; bool y[100100000] = {0}; int t = 0; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;q); for (int i = 2; i \u0026lt;= n; i++) { if (!y[i]) { x[t++] = i; } for (int j = 0; j \u0026lt; t \u0026amp;\u0026amp; i * x[j] \u0026lt;= n; j++) { y[i * x[j]] = 1; if (i % x[j] == 0) break; } } for (int i = 0; i \u0026lt; q; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); if (a \u0026lt;= 0 || a \u0026gt; t) { printf(\u0026#34;Invalid input\\n\u0026#34;); } else { printf(\u0026#34;%d\\n\u0026#34;, x[a - 1]); // 改成0-based索引 } } return 0; } 解法 欧拉筛，线性筛，总体思路是先筛2（最多两倍），然后读入一个素数，然后再筛2，3（最多3倍），然后读入一个素数，这样一直添加。可以保证添加的一定为素数\n模板 快速幂 给你三个整数 a,b,p，求 a b mod p。\n输入格式 输入只有一行三个整数，分别代表 a,b,p。\n输出格式 输出一行一个字符串 a^b mod p=s，其中 a,b,p 分别为题目给定的值， s 为运算结果。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; long long x[47483648] = {}; long long fx(long long a, long long b, long long p) { long long lld, e; if (b == 1) return a % p; long long c = b / 2; if (c\u0026lt; 47483648\u0026amp;\u0026amp;x[c] != 0) lld = x[c]; else lld = fx(a, c, p); if(b\u0026lt; 47483648) x[b] = lld * e % p; return lld * e % p; } int main() { long long a, b, c, lld, p, s; scanf(\u0026#34;%lld %lld %lld\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;p); c = fx(a, b, p); printf(\u0026#34;%lld^%lld mod %lld=%lld\u0026#34;, a, b, p, c); return 0; } 解法 一定要long long 不然中途回爆炸，将幂转换成二进制使用，维护一个答案，当幂上出现奇数的时候对答案乘上一个base，然后将base幂一下，幂指数b也除以二\n括号配对II 高级语言程序设计中的各种括号应该匹配，例如：“(” 与 “)”匹配、“[”与 “]” 匹配、“{”与 “}” 匹配等。 输入一字符文件，判断其中的括号是否匹配。假设括号没有优先级差别。\n输入格式: 多行，字符个数不超过 65536。\n输出格式: 一个单词，表示字符文件中括号匹配的结果，匹配输出“yes”，否则输出“no”.\n输入样例: 在这里给出一组输入。例如：\n( { } ) {a=(b*c)+free( ) }。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;stdio.h\u0026gt; char x[1000]={\u0026#39;#\u0026#39;}; int main(void) { int a = 1, b = 1, c, d; char ch; while (scanf(\u0026#34;%c\u0026#34;,\u0026amp;ch)!=EOF) { if (ch == \u0026#39;(\u0026#39; || ch == \u0026#39;{\u0026#39; || ch == \u0026#39;[\u0026#39;) { x[a] = ch; a++; } if (ch == \u0026#39;)\u0026#39;) { if (x[a - 1] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; a \u0026gt;= 1) { a--; x[a] = 0; } else { b = 0; break; } } if (ch == \u0026#39;]\u0026#39;) { if (x[a - 1] == \u0026#39;[\u0026#39; \u0026amp;\u0026amp; a \u0026gt;= 1) { a--; x[a] = 0; } else { b = 0; break; } } if (ch == \u0026#39;}\u0026#39;) { if (x[a - 1] == \u0026#39;{\u0026#39;\u0026amp;\u0026amp;a\u0026gt;=1) { a--; x[a] = 0; } else { b = 0; break; } } } if (b == 0 || a != 1) printf(\u0026#34;no\u0026#34;); else printf(\u0026#34;yes\u0026#34;); return 0; } 解法 使用栈结构，使用while (scanf(\u0026quot;%c\u0026quot;,\u0026amp;ch)!=EOF)来判断是否还有输入\nBlah数集 大数学家高斯小时候偶然发现一种有趣的自然数集合Blah。以a为基的集合Ba定义如下：\na是集合Ba的基，且a是Ba的第一个元素； 若x在集合Ba中，则2x+1和3x+1也都在Ba中； 没有其它元素在集合Ba中。 现在小高斯想知道如果将集合Ba中元素按照升序排列，第n个元素会是多少？ 输入格式: 多行，每行包括两个数，集合的基a(1\u0026lt;=a\u0026lt;=50))以及所求元素序号n(1\u0026lt;=n\u0026lt;=1000000)\n输出格式: 对于每个输入，输出集合Ba的第n个元素值\n输入样例: 在这里给出一组输入。例如：\n1 5 25 100000\n输出样例: 在这里给出相应的输出。例如：\n9 34503679\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;stdio.h\u0026gt; long long x[1000000]; int main(void) { long long a = 0, b = 0, c = 1, n, i; while (scanf(\u0026#34;%lld %lld\u0026#34;, \u0026amp;i, \u0026amp;n) != EOF) { x[0] = i; a = 0; b = 0; for (c = 1; c \u0026lt;= n; c++) { if ((x[a] * 2 + 1 == x[b] * 3 + 1)) { x[c] = x[a] * 2 + 1; a++; b++; } else if (x[a] * 2 + 1 \u0026lt; x[b] * 3 + 1) { x[c] = x[a] * 2 + 1; a++; } else { x[c] = x[b] * 3 + 1; b++; } } printf(\u0026#34;%lld\\n\u0026#34;, x[n-1]); } } 解法 维护2x+1与3x+1两个指针，都大于已有的最后一个数，然后比较，添加进入。\n左侧最近小数 对N个非负整数的序列，查询元素A i左侧最近的小于A i ​ 的整数(1≤i≤N)，如果不存在，输出 -1\n输入格式: 第1行，1个整数N，表示整数的个数，(1≤N≤100000)。\n第2行，N个整数，每个整数x 都满足 0 ≤ x ≤2000000000。\n输出格式: 1行,N个整数，表示每个元素A i ​ 左侧最近的小于A i ​ 的整数(1≤i≤N)。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; long long x[100000] = {-1}; int main(void) { long long a, b=0, c, d, n, i; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for (a = 0; a \u0026lt; n; a++) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;i); for (; x[b] \u0026gt;= i;b--) { x[b] = 0; } if (i \u0026gt; x[b]) { if(n-a!=1) printf(\u0026#34;%lld \u0026#34;, x[b]); else printf(\u0026#34;%lld\u0026#34;, x[b]); b++; x[b] = i; } } } 解法 维护一个单调栈，从左往右读，每次跟最上边比，大就入栈，小就弹栈再比\n区间最小值I 对N个整数的序列，从左到右连续查询 M 长度子序列 A i ​ ,A i+1 ​ ,\u0026hellip;,A i−M+1 ​ (1≤i，M≤N)的最小值。\n输入格式: 第1行，两个整数：N和M，表示整数的个数和区间长度，1≤N≤100000. 第2行，N个整数，每个整数x 都满足 │x│≤2000000000。\n输出格式: 1行, 用空格分隔的N-M+1个整数，对应从左到右所有连续M长度子序列的最小值。\n输入样例: 6 3 1 2 5 3 4 6 输出样例: 1 2 3 3 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;stdio.h\u0026gt; long long x[100000][2]; int main(void) { long long n, m, a, b, c = 0, d = 0, i; scanf(\u0026#34;%lld %lld\u0026#34;, \u0026amp;n, \u0026amp;m); for (a = 0; a \u0026lt; n; a++) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;i); for (b = c; b \u0026gt;= 0; b--) //单调性维护 { if (b == d || i \u0026gt; x[b - 1][0]) { x[b][0] = i; x[b][1] = a; c++; break; } else { x[b - 1][0] = 0; x[b - 1][1] = 0; c--; } } if (x[c - 1][1] - x[d][1] \u0026gt;= m) //区间维护 { x[d][1] = 0; x[d][0] = 0; d++; } if (a + 1 \u0026gt;= m) { if(n-a!=1) printf(\u0026#34;%lld \u0026#34;, x[d][0]); else printf(\u0026#34;%lld\u0026#34;, x[d][0]); } } } 解法 使用两个数组，一个存数字，一个存下标，一个移动的指针指向最小，只有递增的加入队列，左指针随着移动，分为单调性维护和区间维护\n206. 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例 1： 输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1]\n示例 2： 输入：head = [1,2] 输出：[2,1]\n示例 3： 输入：head = [] 输出：[]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* nex=head; ListNode* now=nullptr; ListNode* temp; while(nex!=nullptr) { temp=nex-\u0026gt;next; nex-\u0026gt;next=now; now=nex; nex=temp; } return now; } }; 解法 使用三个指针，两个负责反向，一个负责指向下一个位置\n234. 回文链表 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。\n示例 1： 输入：head = [1,2,2,1] 输出：true\n示例 2： 输入：head = [1,2] 输出：false\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: bool isPalindrome(ListNode* head) { int x[50110]; int num=0; while(head!=null) { x[num]=head-\u0026gt;val; head=head-\u0026gt;next; num++; } for(int i=0,j=num-1;i\u0026lt;j;i++,j--) { if(x[i]!=x[j]) { return false; } } return true; } }; 解法 用数组将链表读取，然后双指针一左一右对进判断，时间复杂度O（n）\n141. 环形链表 给你一个链表的头节点 head ，判断链表中是否有环。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。\n如果链表中存在环 ，则返回 true 。 否则，返回 false 。\n示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。\n示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。\n示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: bool hasCycle(ListNode *head) { unordered_set\u0026lt;ListNode*\u0026gt; hash; while(head!=nullptr) { if(hash.count(head)) { return true; } hash.insert(head); head=head-\u0026gt;next; } return false; } }; 解法 使用unordered_set,对每个加入的节点搜索，看看有没有一样的（使用数组一样的，只是时间复杂度会高\n21. 合并两个有序链表 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n示例 1： 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4]\n示例 2： 输入：l1 = [], l2 = [] 输出：[]\n示例 3： 输入：l1 = [], l2 = [0] 输出：[0]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) { struct ListNode* head; struct ListNode* p; if(list1==NULL\u0026amp;\u0026amp;list2==NULL) { return NULL; } if(list1!=NULL\u0026amp;\u0026amp;list2==NULL) { return list1; } if(list2!=NULL\u0026amp;\u0026amp;list1==NULL) { return list2; } if(list1-\u0026gt;val\u0026gt;=list2-\u0026gt;val) { head=list2; p=list2; list2=list2-\u0026gt;next; } else { head=list1; p=list1; list1=list1-\u0026gt;next; } while((list1!=NULL)||(list2!=NULL)) { if(list1==NULL\u0026amp;\u0026amp;list2!=NULL) { p-\u0026gt;next=list2; list2=list2-\u0026gt;next; p=p-\u0026gt;next; break; } if(list2==NULL\u0026amp;\u0026amp;list1!=NULL) { p-\u0026gt;next=list1; list1=list1-\u0026gt;next; p=p-\u0026gt;next; break; } if(list1-\u0026gt;val\u0026gt;=list2-\u0026gt;val) { p-\u0026gt;next=list2; list2=list2-\u0026gt;next; p=p-\u0026gt;next; } else { p-\u0026gt;next=list1; list1=list1-\u0026gt;next; p=p-\u0026gt;next; } } return head; } 解法 极度丑陋的代码，主要部分是维护三个指针，两个分别指着a，b，一个指着目标。但是需要考虑空，就需要超级多的if，else语句\n94. 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\n示例 1： 输入：root = [1,null,2,3] 输出：[1,3,2]\n示例 2： 输入：root = [] 输出：[]\n示例 3： 输入：root = [1] 输出：[1]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: void inorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root==nullptr) { return; } inorder(root-\u0026gt;left,res); res.push_back(root-\u0026gt;val); inorder(root-\u0026gt;right,res); } vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; inorder(root,res); return res; } }; 解法 传入一个栈，用res.push_back(root-\u0026gt;val);压入\n104. 二叉树的最大深度 给定一个二叉树 root ，返回其最大深度。\n二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。\n示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：3\n示例 2： 输入：root = [1,null,2] 输出：2\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int deep (TreeNode* root,int d) { if(root==nullptr) { return d; } int l=deep(root-\u0026gt;left,d+1); int r=deep(root-\u0026gt;right,d+1); if(l\u0026gt;=r) { return l; } else{ return r; } } int maxDepth(TreeNode* root) { int i=deep(root,0); return i; } }; 解法 二叉树大部分用的都是递归，取左+取右，比较\n226. 翻转二叉树 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\n示例 1： 输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1]\n示例 2： 输入：root = [2,1,3] 输出：[2,3,1]\n示例 3： 输入：root = [] 输出：[]\n代码 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: TreeNode* invertTree(TreeNode* root) { if(root==nullptr) return nullptr; TreeNode *temp=root-\u0026gt;left; invertTree(root-\u0026gt;left); invertTree(root-\u0026gt;right); root-\u0026gt;left=root-\u0026gt;right; root-\u0026gt;right=temp; return root; } }; 解法 二叉树大部分用的都是递归，左子树先换，右子树再换，最后在根节点换\n101. 对称二叉树 给你一个二叉树的根节点 root ， 检查它是否轴对称。\n示例 1： 输入：root = [1,2,2,3,4,4,3] 输出：true\n示例 2： 输入：root = [1,2,2,null,3,null,3] 输出：false\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: bool fx(TreeNode* left,TreeNode* right){ if(left==nullptr\u0026amp;\u0026amp;right==nullptr){ return true; } if(left==nullptr\u0026amp;\u0026amp;right!=nullptr){ return false; } if(left!=nullptr\u0026amp;\u0026amp;right==nullptr){ return false; } if(left-\u0026gt;val==right-\u0026gt;val){ int a=fx(left-\u0026gt;left,right-\u0026gt;right); int b=fx(left-\u0026gt;right,right-\u0026gt;left); if(a==true\u0026amp;\u0026amp;b==true){ return true; } else{ return false; } } return false; } bool isSymmetric(TreeNode* root) { return fx(root-\u0026gt;left,root-\u0026gt;right); } }; 解法 二叉树大部分用的都是递归，传入左右两个节点，对称的来比较\n","date":"0001-01-01T00:00:00Z","image":"http://localhost:5029/p/%E6%B4%9B%E8%B0%B7/e7037b88f726314190e4c31d32139470245f14a1_hu14003779742696075168.png","permalink":"http://localhost:5029/p/%E6%B4%9B%E8%B0%B7/","title":"洛谷"}]